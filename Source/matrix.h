/********************************************************************\
| Matrix.h: C++ matrix template class include file (Ver.1.0)         |
|                                                                    |
| Copyright (c) 1997-1998 by Somnath Kundu. (See Copying.lib file.)  |
\********************************************************************/

/********************************************************************\
Purpose: This matrix template class defines majority of the matrix
operations as overloaded operators or methods. Users of this class
have been assumed to be familiar with matrix algebra. I have not
defined any specialization of this template here, so all the instances
of matrix will be created implicitly by the compiler. The data types
tested with this class are float, double, long double, complex<float>,
complex<double>, complex<long double>. I think there should not be
any problem with very large precision floating point classes.

Since implementation of exception, namespace and template are still
not standardized among the various compilers, you may encounter
compilation error with some compiler. In that case remove any of
the above three features by defining the following macros:

_NO_EXCEPTION:  Define this macro to remove exception handling
                  and use old style of error handling using function.

_NO_TEMPLATE:   If this macro is defined matrix class of double
                type will be generated by default. You can also
                generate a different type of matrix like float.

Since all the definitions are also included in this header file as
inline function, some compiler may give warning "inline function
can't be expanded". You may ignore/disable this warning using compiler
switches. All the operators/methods defined in this class have their
natural meaning except the followings:

Operator/Method                          Description
---------------                          -----------
operator ()   :   This function operator can be used as a
                  two-dimensional subscript operator to get/set
                  individual matrix elements.

operator !    :   This operator has been used to calculate inversion
                  of matrix.

operator ~    :   This operator has been used to return transpose of
                  a matrix.

operator ^    :   It is used calculate power (by a scalar) of a matrix.
                  When using this operator in a matrix equation, care
                  must be taken by parenthesizing it because it has
                  lower precedence than addition, subtraction,
                  multiplication and division operators.

operator >>   :   It is used to read matrix from input stream as per
                  standard C++ stream operators.

operator <<   :   It is used to write matrix to output stream as per
                  standard C++ stream operators.

If you have any suggestion/bug report, please send it to
somnath@kagi.com with details such as compiler used with
version number, OS and switches used to compile. Since you
have got the source code, it would be better if you solve
any syntactic problem for compilation yourself, because I
may not have access to that specific compiler/OS.
\********************************************************************/
#ifndef __STD_MATRIX_H
#define __STD_MATRIX_H

#include <cstdlib>
#include <cmath>
#include <stdexcept>

#ifndef __MINMAX_DEFINED
#  define __min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

namespace math
{

#if !defined(_NO_EXCEPTION)
class matrix_error : public std::logic_error
{
public:
	matrix_error(const std::string& what_arg) : std::logic_error(what_arg) {}
	virtual ~matrix_error() throw() {}
};
#define REPORT_ERROR(ErrormMsg) throw matrix_error( ErrormMsg);
#else
inline void _matrix_error (const char* ErrMsg)
{
	cout << ErrMsg << endl;
	exit(1);
}
#define REPORT_ERROR(ErrMsg)  _matrix_error(ErrMsg);
#endif

#define MAT_TEMPLATE  template <typename T>
#define matrixT matrix<T>

MAT_TEMPLATE class matrix
{
private:
	T** Val;
	size_t Row, Col, RowSiz, ColSiz;

	void realloc (size_t row, size_t col);
	int pivot (size_t row);
	int pivotCol (size_t row);

public:
	// Constructors
	matrix (const matrixT& m);
	matrix (size_t row = 6, size_t col = 6);

	// Destructor
	~matrix ();

	// Value extraction method
	size_t RowNo() const { return Row; }
	size_t ColNo() const { return Col; }

	// Subscript operator
	T& operator () (size_t row, size_t col);

	// Unary operators
	matrixT operator + () { return *this; }
	matrixT operator - ();

	// Assignment operators
	matrixT& operator = (const matrixT& m);

	// Combined assignment - calculation operators
	matrixT& operator += (const matrixT& m);
	matrixT& operator -= (const matrixT& m);
	matrixT& operator *= (const matrixT& m);
	matrixT& operator *= (const T& c);
	matrixT& operator /= (const T& c);
	matrixT& operator ^= (const size_t& pow);
	matrixT multiplied(const matrixT& m);

	// Logical operators
//	/*friend*/ bool operator == (const matrixT& m1, const matrixT& m2);
//	/*friend*/ bool operator != (const matrixT& m1, const matrixT& m2);

	// Calculation operators
	void Invert(matrixT& result);
#if !defined(_MSC_VER) || _MSC_VER > 1020
	friend matrixT operator / (const matrixT& m, const T& no) { return (m*(1/no)); }
	friend matrixT operator / (const T& no, const matrixT& m) { return (!m * no); }
#endif
	// Miscellaneous -methods
	void Unit ();
	void SetSize(size_t row, size_t col);

	// Utility methods
	matrixT Solve (const matrixT& v) const;
	matrixT Adj ();
	T Det ();
	int Rank ();
	T Norm ();
	T Cofact (size_t row, size_t col);
	T Cond ();

	// Type of matrices
	bool IsSquare () { return (Row == Col); }
	bool IsSingular ();
	bool IsDiagonal ();
	bool IsScalar ();
	bool IsUnit ();
	bool IsNull ();
	bool IsSymmetric ();
	bool IsSkewSymmetric ();
	bool IsUpperTiangular ();
	bool IsLowerTiangular ();
};

// constructor
MAT_TEMPLATE matrixT::matrix (size_t row, size_t col)
{
	RowSiz = Row = row;
	ColSiz = Col = col;
	Val = new T* [row];
	for (size_t i{}; i < row; i++)
	{
		Val[i] = new T [col];
	}
}

// copy constructor
MAT_TEMPLATE matrixT::matrix (const matrixT& m)
{
	RowSiz = Row = m.Row;
	ColSiz = Col = m.Col;

	Val = new T* [Row];
	const size_t colsize(Col * sizeof(T));

	for (size_t i{}; i < Row; i++)
	{
		Val[i] = new T [Col];
		memcpy(Val[i], m.Val[i], colsize);
	}
}


// destructor
MAT_TEMPLATE matrixT::~matrix (void)
{
	for (size_t i{}; i < RowSiz; i++)
	{
		delete [] Val[i];
		Val[i] = 0;
	}
	delete [] Val;
	Val = 0;
}


// reallocation method
MAT_TEMPLATE void matrixT::realloc(size_t row, size_t col)
{
	if (row == RowSiz && col == ColSiz)
	{
		Row = RowSiz;
		Col = ColSiz;
		return;
	}
	T** Val1{new T* [row]};
	for (size_t i{}; i < row; i++)
		Val1[i] = new T [col];

	size_t colSize{__min(Col, col) * sizeof(T)};
	size_t minRow{__min(Row, row)};
   
	for (size_t i{}; i < minRow; i++)
		memcpy(Val1[i], Val[i], colSize);

	for (size_t i{}; i < RowSiz; i++)
	{
		delete [] Val[i];
		Val[i] = 0;
	}
	delete [] Val;

	RowSiz = Row = row;
	ColSiz = Col = col;
	Val = Val1;
}

// public method for resizing matrix
MAT_TEMPLATE void matrixT::SetSize (size_t row, size_t col)
{
	const size_t oldRow{Row};
	const size_t oldCol{Col};

	if (row != RowSiz || col != ColSiz)
	{
		realloc( row, col);
	}
	if (row > oldRow)
	{
		for (size_t i{oldRow}; i < row; i++)
			for (size_t j{}; j < oldCol; j++)
				Val[i][j] = T(0);
	}
	if (col > oldCol)
	{
		for (size_t i{}; i < col; i++)
		{
			for (size_t j{oldCol}; j < col; j++)
				Val[i][j] = T(0);
		}
	}
}

// subscript operator to get/set individual elements
MAT_TEMPLATE T&
matrixT::operator () (size_t row, size_t col)
{
	if (row >= Row || col >= Col)
		REPORT_ERROR( "matrixT::operator(): Index out of range!");
	return Val[row][col];
}

// assignment operator
MAT_TEMPLATE matrixT&
matrixT::operator = (const matrixT& m)
{
	if (Row != m.Row || Col != m.Col)
		realloc( m.Row,m.Col);

	const size_t colbyte(m.Col * sizeof(T));

	for (size_t i{}; i < m.Row; i++)
		memcpy(Val[i], m.Val[i], colbyte);

	return *this;
}

// logical equal-to operator
MAT_TEMPLATE bool
operator == (const matrixT& m1, const matrixT& m2)
{
	bool retVal(false);

	if (m1.Row != m2.Row || m1.Col != m2.Col)
		return retVal;

	for (size_t i{}; i < m1.Row; i++)
		for (size_t j{}; j < m1.Col; i++)
		if (m1.Val[i][j] != m2.Val[i][j])
		return retVal;

	return true;
}

// logical no-equal-to operator
MAT_TEMPLATE bool
operator != (const matrixT& m1, const matrixT& m2)
{
	return (m1 == m2) ? false : true;
}


// combined addition and assignment operator
MAT_TEMPLATE matrixT&
matrixT::operator += (const matrixT& m)
{
	if (Row != m.Row || Col != m.Col)
		REPORT_ERROR( "matrixT::operator+= : Inconsistent matrix size in addition!");
	for (size_t i{}; i < m.Row; i++)
		for (size_t j{}; j < m.Col; j++)
		Val[i][j] += m.Val[i][j];
	return *this;
}


// combined subtraction and assignment operator
MAT_TEMPLATE matrixT&
matrixT::operator -= (const matrixT& m)
{
	if (Row != m.Row || Col != m.Col)
		REPORT_ERROR( "matrixT::operator-= : Inconsistent matrix size in subtraction!");

	for (size_t i{}; i < m.Row; i++)
		for (size_t j{}; j < m.Col; j++)
		Val[i][j] -= m.Val[i][j];
	return *this;
}

// combined scalar multiplication and assignment operator
MAT_TEMPLATE matrixT&
matrixT::operator *= (const T& c)
{
	for (size_t i{}; i < Row; i++)
	{
		for (size_t j{}; j < Col; j++)
		{
			Val[i][j] *= c;
		}
	}
	return *this;
}

MAT_TEMPLATE matrixT matrixT::multiplied(const matrixT& m2)
{
	if (Col != m2.Row)
	{
		REPORT_ERROR( "matrixT::operator*: Inconsistent matrix size in multiplication!");
	}
	matrixT product(Row, m2.Col);
	for (size_t i{}; i < Row; i++)
		for (size_t j{}; j < m2.Col; j++)
	{
		product.Val[i][j] = T(0);
		for (size_t k{}; k < Col; k++)
		{
			product.Val[i][j] += Val[i][k] * m2.Val[k][j];
		}
	}
	return product;
}

// combined matrix multiplication and assignment operator
MAT_TEMPLATE matrixT&
matrixT::operator *= (const matrixT& m)
{
	if (Col != m.Row)
	{
		REPORT_ERROR( "matrixT::operator*= : Inconsistance matrix size in multiplication!");
	}
	*this = *this * m;
	return *this;
}


// combined scalar division and assignment operator
MAT_TEMPLATE matrixT&
matrixT::operator /= (const T& c)
{
	for (size_t i{}; i < Row; i++)
	{
		for (size_t j{}; j < Col; j++)
			Val[i][j] /= c;
	}

	return *this;
}

// combined power and assignment operator
MAT_TEMPLATE matrixT&
matrixT::operator ^= (const size_t& pow)
{
	for (size_t i=2; i <= pow; i++)
	{
		*this = *this * *this;
	}
	return *this;
}

// unary negation operator
MAT_TEMPLATE matrixT
matrixT::operator - ()
{
	matrixT temp(Row,Col);

	for (size_t i{}; i < Row; i++)
		for (size_t j{}; j < Col; j++)
		temp.Val[i][j] = - Val[i][j];

	return temp;
}

// binary addition operator
MAT_TEMPLATE matrixT
operator + (const matrixT& m1, const matrixT& m2)
{
	if (m1.Row != m2.Row || m1.Col != m2.Col)
		REPORT_ERROR( "matrixT::operator+: Inconsistent matrix size in addition!");

	matrixT temp(m1.Row,m1.Col);

	for (size_t i{}; i < m1.Row; i++)
		for (size_t j{}; j < m1.Col; j++)
		temp.Val[i][j] = m1.Val[i][j] + m2.Val[i][j];

	return temp;
}

// binary subtraction operator
MAT_TEMPLATE matrixT
operator - (const matrixT& m1, const matrixT& m2)
{
	if (m1.Row != m2.Row || m1.Col != m2.Col)
		REPORT_ERROR( "matrixT::operator-: Inconsistent matrix size in subtraction!");

	matrixT temp(m1.Row,m1.Col);

	for (size_t i{}; i < m1.Row; i++)
		for (size_t j{}; j < m1.Col; j++)
		temp.Val[i][j] = m1.Val[i][j] - m2.Val[i][j];

	return temp;
}


// scalar multiplication operator
MAT_TEMPLATE matrixT
operator * (const matrixT& m, const T& no)
{
	matrixT temp(m.Row,m.Col);
	for (size_t i{}; i < m.Row; i++)
	{
		for (size_t j{}; j < m.Col; j++)
			temp.Val[i][j] = no * m.Val[i][j];
	}
	return temp;
}


// matrix multiplication
MAT_TEMPLATE matrixT operator * (const matrixT& m1, const matrixT& m2)
{
	if (m1.Col != m2.Row)
	{
		REPORT_ERROR( "matrixT::operator*: Inconsistent matrix size in multiplication!");
	}
	matrixT temp(m1.Row,m2.Col);
	for (size_t i{}; i < m1.Row; i++)
		for (size_t j{}; j < m2.Col; j++)
	{
		temp.Val[i][j] = T(0);
		for (size_t k{}; k < m1.Col; k++)
		{
			temp.Val[i][j] += m1.Val[i][k] * m2.Val[k][j];
		}
	}
	return temp;
}

// binary power operator
MAT_TEMPLATE matrixT
operator ^ (const matrixT& m, const size_t& pow)
{
	matrixT temp(m);

	for (size_t i=2; i <= pow; i++)
		temp = temp * temp;

	return temp;
}


// unary transpose operator
MAT_TEMPLATE matrixT
operator ~ (const matrixT& m)
{
	matrixT temp(m.Col,m.Row);

	for (size_t i{}; i < m.Row; i++)
	{
		for (size_t j{}; j < m.Col; j++)
			temp.Val[j][i] = m.Val[i][j];
	}

	return temp;
}


// unary inversion operator
MAT_TEMPLATE matrixT
operator ! (matrixT m)
{
	if (m.Row != m.Col)
		REPORT_ERROR( "matrixT::operator!: Inversion of a non-square matrix");

	matrixT temp(m.Row,m.Col);

	temp.Unit();
	for (size_t k{}; k < m.Row; k++)
	{
		int indx(m.pivot(k));
		if (indx == -1)
		{
			REPORT_ERROR( "matrixT::operator!: Inversion of a singular matrix");
		}

		if (indx != 0)
		{
			T* rowptr = temp.Val[k];
			temp.Val[k] = temp.Val[indx];
			temp.Val[indx] = rowptr;
		}
		T a1(m.Val[k][k]);
		for (size_t j{}; j < m.Row; j++)
		{
			m.Val[k][j] /= a1;
			temp.Val[k][j] /= a1;
		}
		for (size_t i{}; i < m.Row; i++)
			if (i != k)
		{
			T a2(m.Val[i][k]);
			for (size_t j{}; j < m.Row; j++)
			{
				m.Val[i][j] -= a2 * m.Val[k][j];
				temp.Val[i][j] -= a2 * temp.Val[k][j];
			}
		}
	}
	return temp;
}

// matrix inversion
MAT_TEMPLATE void matrixT::Invert(matrixT& result)
{
	if (Row != Col)
		REPORT_ERROR( "matrixT::operator!: Inversion of a non-square matrix");
	result.SetSize(Row, Col);
	result.Unit();

	matrixT m(*this);

	for (size_t k{}; k < m.Row; k++)
	{
		int indx(m.pivot(k));
		if (indx == -1)
		{
			REPORT_ERROR( "matrixT::operator!: Inversion of a singular matrix");
		}

		if (indx != 0)
		{
			T* rowptr = result.Val[k];
			result.Val[k] = result.Val[indx];
			result.Val[indx] = rowptr;
		}
		T a1(m.Val[k][k]);
		for (size_t j{}; j < m.Row; j++)
		{
			m.Val[k][j] /= a1;
			result.Val[k][j] /= a1;
		}
		for (size_t i{}; i < m.Row; i++)
			if (i != k)
		{
			T a2(m.Val[i][k]);
			for (size_t j{}; j < m.Row; j++)
			{
				m.Val[i][j] -= a2 * m.Val[k][j];
				result.Val[i][j] -= a2 * result.Val[k][j];
			}
		}
	}
}

// solve simultaneous equation
MAT_TEMPLATE matrixT
matrixT::Solve (const matrixT& v) const
{
	T a1;

	if (!(Row == Col && Col == v.Row))
		REPORT_ERROR( "matrixT::Solve():Inconsistent matrices!");

	matrixT temp(Row,Col+v.Col);
	for (int i{}; i < Row; i++)
	{
		for (int j{}; j < Col; j++)
			temp.Val[i][j] = Val[i][j];
		for (int k{}; k < v.Col; k++)
			temp.Val[i][Col+k] = v.Val[i][k];
	}
	for (int k{}; k < Row; k++)
	{
		int indx{temp.pivot(k)};
		if (indx == -1)
			REPORT_ERROR( "matrixT::Solve(): Singular matrix!");

		a1 = temp.Val[k][k];
		for (int j{k}; j < temp.Col; j++)
			temp.Val[k][j] /= a1;

		for (int i{k+1}; i < Row; i++)
		{
			a1 = temp.Val[i][k];
			for (int j{k}; j < temp.Col; j++)
				temp.Val[i][j] -= a1 * temp.Val[k][j];
		}
	}
	matrixT s(v.Row,v.Col);
	for (int k{}; k < v.Col; k++)
		for (int m=int(Row)-1; m >= 0; m--)
	{
		s.Val[m][k] = temp.Val[m][Col+k];
		for (int j{m+1}; j < Col; j++)
			s.Val[m][k] -= temp.Val[m][j] * s.Val[j][k];
	}
	return s;
}

// set this matrix to unity
MAT_TEMPLATE void
matrixT::Unit ()
{
	const size_t row{__min(Row,Col)};
	Row = Col = row;

	for (size_t i{}; i < Row; i++)
		for (size_t j{}; j < Col; j++)
		Val[i][j] = i == j ? T(1) : T(0);
	return;
}

/*******************************************************************************
private partial pivoting method
Starts at diagonal in given row, scans rows below, moves pivot row to diagonal
@return pivotRow, 0 when pivot was already on diagonal, -1 when no pivot.
*******************************************************************************/
MAT_TEMPLATE int
matrixT::pivot (size_t row)
{
	int pivRow{static_cast<int>(row)};
	double amax{-1.0};
	for (size_t rx{row}; rx < Row; rx++)
	{	// Scan below
		const std::complex<double> cmplx( Val[rx][row]);
		const double temp( std::abs( cmplx));
		if ( temp > amax && temp > 0.0)
		{
			// Pivot candidate
			amax = temp;
			pivRow = rx;
		}
	}
	if (amax < 0.0)
	{
		return -1;
	}
	if (pivRow != int(row))
	{	// Move pivRow up to diagonal
		T* rowptr = Val[pivRow];
		Val[pivRow] = Val[row];
		Val[row] = rowptr;
		//std::cout << *this;
		return pivRow;
	}
	return 0;
}

/*******************************************************************************
pivoting method
Starts at diagonal in given row, scans columns to the right, moves
 pivot column to diagonal position.
@return pivotCol, 0 when pivot was already on diagonal, -1 when no pivot.
*******************************************************************************/
MAT_TEMPLATE int
matrixT::pivotCol (size_t row)
{
	int pivCol{static_cast<int>(row)};
	double amax{-1.0};
	for (size_t cx{row}; cx < Col; cx++)
	{	// Scan right
		const std::complex<double> cmplx(Val[row][cx]);
		const double temp{std::abs( cmplx)};
		if ( temp > amax && temp > 0.0)
		{
			// Pivot candidate
			amax = temp;
			pivCol = cx;
		}
	}
	if (amax < 0.0)
	{
		return -1;
	}
	if (pivCol != int(row))
	{	// Move column containing pivot to diagonal
		for (size_t rx{row}; rx < Row; rx++)
		{
			T val{Val[rx][row]};
			Val[rx][row] = Val[rx][pivCol];
			Val[rx][pivCol] = val;
		}
		return pivCol;
	}
	return 0;
}

// calculate the determinant of a matrix
MAT_TEMPLATE T
matrixT::Det ()
{
	if (Row != Col)
	{
		REPORT_ERROR( "matrixT::Det(): Determinant a non-square matrix!");
	}
	matrixT temp(*this);
	T detVal = T(1);
	for (size_t k{}; k < Row; k++)
	{
		int indx{temp.pivot(k)};
		if (indx == -1)
		{
			return 0;
		}
		if (indx != 0)
		{
			detVal = - detVal;
		}
		detVal = detVal * temp.Val[k][k];
		for (size_t i(k + 1); i < Row; i++)
		{	// Clear column below
			T piv(temp.Val[i][k] / temp.Val[k][k]);
			for (size_t j(k + 1); j < Row; j++)
			{
				temp.Val[i][j] -= piv * temp.Val[k][j];
			}
		}
	}
	return detVal;
}

/*******************************************************************************
calculate the rank of a matrix
*******************************************************************************/
MAT_TEMPLATE int matrixT::Rank()
{
	matrixT temp(*this);
	int rank{int(Row)};
	for (size_t dx{}; dx < Row; dx++)
	{
		//cout << temp << "---??---\n";
		int indx{temp.pivot(dx)};
		if (indx == -1)
		{
			indx = temp.pivotCol(dx);
			//cout << temp << "--(used col" << indx << ")----\n";

		}
		if (indx < 0)
		{
			rank--;
		}
		else
		{
			const T piv(temp.Val[dx][dx]);
			for (size_t rx{dx + 1}; rx < Row; rx++)
			{	// Rows below
				const T fact(temp.Val[rx][dx] / piv);
				for (size_t cx{dx + 1}; cx < Col; cx++)
				{	// Subtract multiple of pivot row
					temp.Val[rx][cx] -= fact * temp.Val[dx][cx];
				}
			}
			//cout << temp << "------\n";
		}
	}
	return rank;
}

// calculate the norm of a matrix
MAT_TEMPLATE T
matrixT::Norm ()
{
	T retVal{};
	for (size_t i{}; i < Row; i++)
	{
		for (size_t j{}; j < Col; j++)
			retVal += Val[i][j] * Val[i][j];
	}
	retVal = sqrt( retVal);
	return retVal;
}


// calculate the condition number of a matrix
MAT_TEMPLATE T
matrixT::Cond ()
{
	matrixT inv(Row,Col);
	inv = ! (*this);
	T retVal = Norm() * inv.Norm();
	return retVal;
}


// calculate the cofactor of a matrix for a given element
MAT_TEMPLATE T matrixT::Cofact (size_t row, size_t col)
{
	if (Row != Col)
		REPORT_ERROR( "matrixT::Cofact(): Cofactor of a non-square matrix!");
	if (row > Row || col > Col)
		REPORT_ERROR( "matrixT::Cofact(): Index out of range!");

	matrixT temp(Row-1, Col-1);

	for (int i{}, i1{}; i < Row; i++)
	{
		if (i == row)
			continue;
		for (int j{}, j1{}; j < Col; j++)
		{
			if (j == col)
				continue;
			temp.Val[i1][j1] = Val[i][j];
			j1++;
		}
		i1++;
	}
	T cof{temp.Det()};
	if ((row+col)%2 == 1)
		cof = -cof;

	return cof;
}


// calculate adjoin of a matrix
MAT_TEMPLATE matrixT matrixT::Adj ()
{
	if (Row != Col)
		REPORT_ERROR( "matrixT::Adj(): Adjoin of a non-square matrix.");

	matrixT temp(Row,Col);

	for (size_t i{}; i < Row; i++)
		for (size_t j{}; j < Col; j++)
		temp.Val[i][j] = Cofact(i,j);

	temp = ~temp;
	return temp;
}

// Determine if the matrix is singular
MAT_TEMPLATE bool
matrixT::IsSingular ()
{
	if (Row != Col)
		return false;
	return (Det() == T(0));
}

// Determine if the matrix is diagonal
MAT_TEMPLATE bool
matrixT::IsDiagonal ()
{
	if (Row != Col)
		return false;
	for (size_t i{}; i < Row; i++)
		for (size_t j{}; j < Col; j++)
		if (i != j && Val[i][j] != T(0))
		return false;
	return true;
}

// Determine if the matrix is scalar
MAT_TEMPLATE bool
matrixT::IsScalar ()
{
	if (!IsDiagonal())
		return false;
	T v = Val[0][0];
	for (size_t i{1}; i < Row; i++)
		if (Val[i][i] != v)
		return false;
	return true;
}

// Determine if the matrix is a unit matrix
MAT_TEMPLATE bool
matrixT::IsUnit ()
{
	if (IsScalar() && Val[0][0] == T(1))
		return true;
	return false;
}

// Determine if this is a null matrix
MAT_TEMPLATE bool
matrixT::IsNull ()
{
	for (size_t i{}; i < Row; i++)
		for (size_t j{}; j < Col; j++)
		if (Val[i][j] != T(0))
		return false;
	return true;
}

// Determine if the matrix is symmetric
MAT_TEMPLATE bool
matrixT::IsSymmetric ()
{
	if (Row != Col)
	{
		return false;
	}
	for (size_t i{}; i < Row; i++)
		for (size_t j{0}; j < Col; j++)
			if (Val[i][j] != Val[j][i])
				return false;
	return true;
}
           
// Determine if the matrix is skew-symmetric
MAT_TEMPLATE bool
matrixT::IsSkewSymmetric ()
{
	if (Row != Col)
	{
		return false;
	}
	for (size_t i{}; i < Row; i++)
	{
		for (size_t j{}; j < Col; j++)
		{
			if (Val[i][j] != -Val[j][i])
			{
				return false;
			}
		}
	}
	return true;
}
   
// Determine if the matrix is upper triangular
MAT_TEMPLATE bool
matrixT::IsUpperTiangular ()
{
	if (Row != Col)
	{
		return false;
	}
	for (size_t i{1}; i < Row; i++)
	{
		for (size_t j{}; j < i-1; j++)
		{
			if (Val[i][j] != T(0))
				return false;
		}
	}
	return true;
}

// Determine if the matrix is lower triangular
MAT_TEMPLATE bool
matrixT::IsLowerTiangular ()
{
	if (Row != Col)
	{
		return false;
	}
	for (size_t j{1}; j < Col; j++)
	{
		for (size_t i{}; i < j-1; i++)
			if (Val[i][j] != T(0))
				return false;
	}
	return true;
}

} 

#endif

